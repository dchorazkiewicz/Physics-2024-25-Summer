{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Physics 2024/25 Summer This is the course website for Physics 2024/25 Summer. Here you will find all the information you need for the course, including the syllabus, schedule, and assignments.","title":"Home"},{"location":"#welcome-to-physics-202425-summer","text":"This is the course website for Physics 2024/25 Summer. Here you will find all the information you need for the course, including the syllabus, schedule, and assignments.","title":"Welcome to Physics 2024/25 Summer"},{"location":"Mechanics/double_pendulum_trajectories/","text":"Double Pendulum and Sensitivity to Initial Conditions Overview The double pendulum is a classic example of a chaotic system. Its motion is highly sensitive to initial conditions, making it an excellent demonstration of chaos in dynamic systems. The equations of motion for the double pendulum are derived from the Lagrangian and are solved numerically for this analysis. Python Code Example: Simulating and Plotting Trajectories Here is a Python code snippet to simulate and visualize the trajectories of a double pendulum for two slightly different initial conditions: import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants for the double pendulum L1, L2 = 1.0, 1.0 # lengths of the pendulum arms M1, M2 = 1.0, 1.0 # masses of the pendulums g = 9.81 # acceleration due to gravity def double_pendulum_ode(t, y): \"\"\"Defines the equations of motion for the double pendulum.\"\"\" theta1, z1, theta2, z2 = y # Unpack the state vector delta = theta2 - theta1 den1 = (M1 + M2) * L1 - M2 * L1 * np.cos(delta) ** 2 den2 = (L2 / L1) * den1 dydt = np.zeros_like(y) dydt[0] = z1 dydt[1] = ( M2 * L1 * z1 ** 2 * np.sin(delta) * np.cos(delta) + M2 * g * np.sin(theta2) * np.cos(delta) + M2 * L2 * z2 ** 2 * np.sin(delta) - (M1 + M2) * g * np.sin(theta1) ) / den1 dydt[2] = z2 dydt[3] = ( -M2 * L2 * z2 ** 2 * np.sin(delta) * np.cos(delta) + (M1 + M2) * g * np.sin(theta1) * np.cos(delta) - (M1 + M2) * L1 * z1 ** 2 * np.sin(delta) - (M1 + M2) * g * np.sin(theta2) ) / den2 return dydt # Initial conditions: two similar starting states y0_1 = [np.pi / 4, 0, np.pi / 2, 0] # [theta1, theta1_dot, theta2, theta2_dot] y0_2 = [np.pi / 4 + 0.01, 0, np.pi / 2, 0] # Slightly perturbed # Time span for the simulation t_span = (0, 20) t_eval = np.linspace(t_span[0], t_span[1], 2000) # Solve the equations of motion sol1 = solve_ivp(double_pendulum_ode, t_span, y0_1, t_eval=t_eval, method='RK45') sol2 = solve_ivp(double_pendulum_ode, t_span, y0_2, t_eval=t_eval, method='RK45') # Plot the trajectories of theta1 and theta2 plt.figure(figsize=(12, 6)) plt.plot(t_eval, sol1.y[0], label=\"Theta1 (Initial 1)\") plt.plot(t_eval, sol1.y[2], label=\"Theta2 (Initial 1)\") plt.plot(t_eval, sol2.y[0], label=\"Theta1 (Initial 2)\", linestyle=\"--\") plt.plot(t_eval, sol2.y[2], label=\"Theta2 (Initial 2)\", linestyle=\"--\") plt.title(\"Trajectories of the Double Pendulum\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle (rad)\") plt.legend() plt.grid() plt.show() # Plot the difference in trajectories plt.figure(figsize=(12, 6)) plt.plot(t_eval, np.abs(sol1.y[0] - sol2.y[0]), label=\"|Theta1 Difference|\") plt.plot(t_eval, np.abs(sol1.y[2] - sol2.y[2]), label=\"|Theta2 Difference|\") plt.title(\"Difference Between Trajectories\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle Difference (rad)\") plt.legend() plt.grid() plt.show() Key Insights Trajectories Diverge Rapidly: Even with a small initial difference, the trajectories of the double pendulum diverge quickly, illustrating chaotic behavior. Visualization of Sensitivity: The second plot clearly shows how the differences grow over time, emphasizing the system's sensitivity to initial conditions. Suggested Projects Energy Analysis: Calculate and plot the total energy of the system to verify conservation laws. 3D Visualization: Extend the analysis to visualize the pendulum's motion in 3D space. Real-World Experiment: Compare the simulation to a physical double pendulum setup. Parameter Variation: Investigate how varying lengths and masses affect the system's dynamics. This example demonstrates the chaotic nature of the double pendulum and its sensitivity to initial conditions. Try modifying the initial states or parameters to observe how the system behaves!","title":"Double Pendulum"},{"location":"Mechanics/double_pendulum_trajectories/#double-pendulum-and-sensitivity-to-initial-conditions","text":"","title":"Double Pendulum and Sensitivity to Initial Conditions"},{"location":"Mechanics/double_pendulum_trajectories/#overview","text":"The double pendulum is a classic example of a chaotic system. Its motion is highly sensitive to initial conditions, making it an excellent demonstration of chaos in dynamic systems. The equations of motion for the double pendulum are derived from the Lagrangian and are solved numerically for this analysis.","title":"Overview"},{"location":"Mechanics/double_pendulum_trajectories/#python-code-example-simulating-and-plotting-trajectories","text":"Here is a Python code snippet to simulate and visualize the trajectories of a double pendulum for two slightly different initial conditions: import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants for the double pendulum L1, L2 = 1.0, 1.0 # lengths of the pendulum arms M1, M2 = 1.0, 1.0 # masses of the pendulums g = 9.81 # acceleration due to gravity def double_pendulum_ode(t, y): \"\"\"Defines the equations of motion for the double pendulum.\"\"\" theta1, z1, theta2, z2 = y # Unpack the state vector delta = theta2 - theta1 den1 = (M1 + M2) * L1 - M2 * L1 * np.cos(delta) ** 2 den2 = (L2 / L1) * den1 dydt = np.zeros_like(y) dydt[0] = z1 dydt[1] = ( M2 * L1 * z1 ** 2 * np.sin(delta) * np.cos(delta) + M2 * g * np.sin(theta2) * np.cos(delta) + M2 * L2 * z2 ** 2 * np.sin(delta) - (M1 + M2) * g * np.sin(theta1) ) / den1 dydt[2] = z2 dydt[3] = ( -M2 * L2 * z2 ** 2 * np.sin(delta) * np.cos(delta) + (M1 + M2) * g * np.sin(theta1) * np.cos(delta) - (M1 + M2) * L1 * z1 ** 2 * np.sin(delta) - (M1 + M2) * g * np.sin(theta2) ) / den2 return dydt # Initial conditions: two similar starting states y0_1 = [np.pi / 4, 0, np.pi / 2, 0] # [theta1, theta1_dot, theta2, theta2_dot] y0_2 = [np.pi / 4 + 0.01, 0, np.pi / 2, 0] # Slightly perturbed # Time span for the simulation t_span = (0, 20) t_eval = np.linspace(t_span[0], t_span[1], 2000) # Solve the equations of motion sol1 = solve_ivp(double_pendulum_ode, t_span, y0_1, t_eval=t_eval, method='RK45') sol2 = solve_ivp(double_pendulum_ode, t_span, y0_2, t_eval=t_eval, method='RK45') # Plot the trajectories of theta1 and theta2 plt.figure(figsize=(12, 6)) plt.plot(t_eval, sol1.y[0], label=\"Theta1 (Initial 1)\") plt.plot(t_eval, sol1.y[2], label=\"Theta2 (Initial 1)\") plt.plot(t_eval, sol2.y[0], label=\"Theta1 (Initial 2)\", linestyle=\"--\") plt.plot(t_eval, sol2.y[2], label=\"Theta2 (Initial 2)\", linestyle=\"--\") plt.title(\"Trajectories of the Double Pendulum\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle (rad)\") plt.legend() plt.grid() plt.show() # Plot the difference in trajectories plt.figure(figsize=(12, 6)) plt.plot(t_eval, np.abs(sol1.y[0] - sol2.y[0]), label=\"|Theta1 Difference|\") plt.plot(t_eval, np.abs(sol1.y[2] - sol2.y[2]), label=\"|Theta2 Difference|\") plt.title(\"Difference Between Trajectories\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle Difference (rad)\") plt.legend() plt.grid() plt.show()","title":"Python Code Example: Simulating and Plotting Trajectories"},{"location":"Mechanics/double_pendulum_trajectories/#key-insights","text":"Trajectories Diverge Rapidly: Even with a small initial difference, the trajectories of the double pendulum diverge quickly, illustrating chaotic behavior. Visualization of Sensitivity: The second plot clearly shows how the differences grow over time, emphasizing the system's sensitivity to initial conditions.","title":"Key Insights"},{"location":"Mechanics/double_pendulum_trajectories/#suggested-projects","text":"Energy Analysis: Calculate and plot the total energy of the system to verify conservation laws. 3D Visualization: Extend the analysis to visualize the pendulum's motion in 3D space. Real-World Experiment: Compare the simulation to a physical double pendulum setup. Parameter Variation: Investigate how varying lengths and masses affect the system's dynamics. This example demonstrates the chaotic nature of the double pendulum and its sensitivity to initial conditions. Try modifying the initial states or parameters to observe how the system behaves!","title":"Suggested Projects"},{"location":"Mechanics/logistic_equation_bifurcation/","text":"Logistic Equation and Bifurcation Overview The logistic equation is a simple mathematical model that describes population growth with a carrying capacity. The equation is: \\[ x_{n+1} = r x_n (1 - x_n) \\] Where: \\(x_n\\) is the population at generation \\(n\\) (normalized between 0 and 1). \\(r\\) is the growth rate parameter. This model exhibits interesting dynamics as the parameter \\(r\\) varies, leading to bifurcations and chaotic behavior. Python Code Example: Simulating and Plotting Bifurcations Here is a Python code snippet to simulate and visualize the bifurcation diagram of the logistic equation: import numpy as np import matplotlib.pyplot as plt # Define the logistic map function, which calculates the next population value # given the current population (x) and the growth rate (r). def logistic_map(r, x): return r * x * (1 - x) # Core equation of the logistic map # Function to generate and plot the bifurcation diagram def bifurcation_diagram(r_min=2.5, r_max=4.0, steps=10000, discard=1000, plot_points=200): # Generate a range of r values between r_min and r_max. r_values = np.linspace(r_min, r_max, steps) # Initialize the population values with an array of 0.5 (arbitrary starting value). x = 0.5 * np.ones(steps) # Set up the figure for plotting. plt.figure(figsize=(10, 7)) # Iterate to discard transient dynamics, ensuring we only analyze steady-state behavior. for _ in range(discard): x = logistic_map(r_values, x) # After discarding transients, iterate again to collect data points for the diagram. for _ in range(plot_points): x = logistic_map(r_values, x) # Plot the r values against the current population values (x). plt.plot(r_values, x, ',k', alpha=0.25) # ',' creates small dots for a dense diagram # Add plot titles and labels for clarity. plt.title(\"Bifurcation Diagram of the Logistic Map\") plt.xlabel(\"Growth Rate (r)\") plt.ylabel(\"Population (x)\") plt.grid(True, alpha=0.5) # Optional grid for better readability plt.show() # Entry point to execute the bifurcation diagram plot. if __name__ == \"__main__\": bifurcation_diagram() # Call the function with default parameters Key Insights Stable Fixed Points: For small \\(r\\) , the population converges to a single fixed point. Periodic Orbits: As \\(r\\) increases, bifurcations occur, leading to periodic cycles. Chaos: For \\(r \\geq 3.57\\) , chaotic behavior is observed, where the population no longer settles into predictable cycles. Applications Ecology: Modeling species populations. Economics: Describing market dynamics. Physics: Exploring chaotic systems. Advanced Exploration Suggested Student Projects Students can extend this analysis in the following ways: Exploration of Lyapunov Exponent: Implement a calculation of the Lyapunov exponent to quantify chaos in the logistic map. This involves computing the average divergence of nearby trajectories. Effect of Initial Conditions: Investigate how varying the initial population \\(x_0\\) affects the bifurcation diagram. Plot diagrams for different \\(x_0\\) values and compare. Parameter Sensitivity: Analyze the sensitivity of the system to small changes in the growth rate \\(r\\) within the chaotic region. Visualize how small perturbations in \\(r\\) can lead to different outcomes. 3D Visualization: Extend the bifurcation diagram to include a time dimension, creating a 3D plot to visualize the dynamics. Applications in Real-World Data: Apply the logistic map to real-world data, such as population studies or stock market fluctuations, to see how well it models observed behaviors. Programming Challenge: Implement the bifurcation diagram using a different programming language or visualization library (e.g., JavaScript with D3.js or MATLAB). This is an introductory example to explore the fascinating behavior of dynamic systems through the logistic equation. Try tweaking the parameters in the code to see how the system's behavior changes!","title":"Logistic Equation"},{"location":"Mechanics/logistic_equation_bifurcation/#logistic-equation-and-bifurcation","text":"","title":"Logistic Equation and Bifurcation"},{"location":"Mechanics/logistic_equation_bifurcation/#overview","text":"The logistic equation is a simple mathematical model that describes population growth with a carrying capacity. The equation is: \\[ x_{n+1} = r x_n (1 - x_n) \\] Where: \\(x_n\\) is the population at generation \\(n\\) (normalized between 0 and 1). \\(r\\) is the growth rate parameter. This model exhibits interesting dynamics as the parameter \\(r\\) varies, leading to bifurcations and chaotic behavior.","title":"Overview"},{"location":"Mechanics/logistic_equation_bifurcation/#python-code-example-simulating-and-plotting-bifurcations","text":"Here is a Python code snippet to simulate and visualize the bifurcation diagram of the logistic equation: import numpy as np import matplotlib.pyplot as plt # Define the logistic map function, which calculates the next population value # given the current population (x) and the growth rate (r). def logistic_map(r, x): return r * x * (1 - x) # Core equation of the logistic map # Function to generate and plot the bifurcation diagram def bifurcation_diagram(r_min=2.5, r_max=4.0, steps=10000, discard=1000, plot_points=200): # Generate a range of r values between r_min and r_max. r_values = np.linspace(r_min, r_max, steps) # Initialize the population values with an array of 0.5 (arbitrary starting value). x = 0.5 * np.ones(steps) # Set up the figure for plotting. plt.figure(figsize=(10, 7)) # Iterate to discard transient dynamics, ensuring we only analyze steady-state behavior. for _ in range(discard): x = logistic_map(r_values, x) # After discarding transients, iterate again to collect data points for the diagram. for _ in range(plot_points): x = logistic_map(r_values, x) # Plot the r values against the current population values (x). plt.plot(r_values, x, ',k', alpha=0.25) # ',' creates small dots for a dense diagram # Add plot titles and labels for clarity. plt.title(\"Bifurcation Diagram of the Logistic Map\") plt.xlabel(\"Growth Rate (r)\") plt.ylabel(\"Population (x)\") plt.grid(True, alpha=0.5) # Optional grid for better readability plt.show() # Entry point to execute the bifurcation diagram plot. if __name__ == \"__main__\": bifurcation_diagram() # Call the function with default parameters","title":"Python Code Example: Simulating and Plotting Bifurcations"},{"location":"Mechanics/logistic_equation_bifurcation/#key-insights","text":"Stable Fixed Points: For small \\(r\\) , the population converges to a single fixed point. Periodic Orbits: As \\(r\\) increases, bifurcations occur, leading to periodic cycles. Chaos: For \\(r \\geq 3.57\\) , chaotic behavior is observed, where the population no longer settles into predictable cycles.","title":"Key Insights"},{"location":"Mechanics/logistic_equation_bifurcation/#applications","text":"Ecology: Modeling species populations. Economics: Describing market dynamics. Physics: Exploring chaotic systems.","title":"Applications"},{"location":"Mechanics/logistic_equation_bifurcation/#advanced-exploration","text":"","title":"Advanced Exploration"},{"location":"Mechanics/logistic_equation_bifurcation/#suggested-student-projects","text":"Students can extend this analysis in the following ways: Exploration of Lyapunov Exponent: Implement a calculation of the Lyapunov exponent to quantify chaos in the logistic map. This involves computing the average divergence of nearby trajectories. Effect of Initial Conditions: Investigate how varying the initial population \\(x_0\\) affects the bifurcation diagram. Plot diagrams for different \\(x_0\\) values and compare. Parameter Sensitivity: Analyze the sensitivity of the system to small changes in the growth rate \\(r\\) within the chaotic region. Visualize how small perturbations in \\(r\\) can lead to different outcomes. 3D Visualization: Extend the bifurcation diagram to include a time dimension, creating a 3D plot to visualize the dynamics. Applications in Real-World Data: Apply the logistic map to real-world data, such as population studies or stock market fluctuations, to see how well it models observed behaviors. Programming Challenge: Implement the bifurcation diagram using a different programming language or visualization library (e.g., JavaScript with D3.js or MATLAB). This is an introductory example to explore the fascinating behavior of dynamic systems through the logistic equation. Try tweaking the parameters in the code to see how the system's behavior changes!","title":"Suggested Student Projects"}]}