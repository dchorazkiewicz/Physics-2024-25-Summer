{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Physics 2024/25 Summer","text":"<p>This is the course website for Physics 2024/25 Summer. Here you will find all the information you need for the course, including the syllabus, schedule, and assignments.</p>"},{"location":"Experiments_Statistics/intro_to_stats/","title":"Statistics","text":""},{"location":"Experiments_Statistics/intro_to_stats/#what-is-a-probability","title":"What is a probability?","text":"<p>Probability is a measure of the likelihood of an event occurring. It is a value between 0 and 1, where 0 indicates an impossible event and 1 indicates a certain event.</p> <p>In mathematical terms, the probability of an event \\(A\\) is calculated as:</p> \\[ P(A) = \\frac{\\text{Number of favorable outcomes}}{\\text{Total number of possible outcomes}} \\] <p>For example, if we roll a fair six-sided die, the probability of rolling a 4 is:</p> \\[ P(4) = \\frac{1}{6} \\]"},{"location":"Experiments_Statistics/intro_to_stats/#simulating-probability-in-python","title":"Simulating Probability in Python","text":"<p>To better understand probabilities, we can use simulations. For instance, we can simulate rolling a die multiple times to estimate the probability of a specific outcome.</p> <p>Here is a Python simulation to estimate the probability of rolling a 4 on a six-sided die:</p> <pre><code>import random\n\n# Function to simulate rolling a die 'n' times\ndef simulate_die_rolls(n):\n    # Generate a list of 'n' random die rolls (values between 1 and 6)\n    rolls = [random.randint(1, 6) for _ in range(n)]\n    # Calculate the proportion of rolls that resulted in a 4\n    return rolls.count(4) / n\n\n# Simulate 10,000 die rolls\nn_rolls = 10000\n# Estimate the probability of rolling a 4\nestimated_probability = simulate_die_rolls(n_rolls)\n# Print the estimated probability\nprint(f\"Estimated probability of rolling a 4: {estimated_probability}\")\n</code></pre> <p>By increasing the number of simulations (\\(n\\)), we get a more accurate estimate of the true probability.</p>"},{"location":"Experiments_Statistics/intro_to_stats/#the-law-of-large-numbers","title":"The Law of Large Numbers","text":"<p>The Law of Large Numbers states that as the number of trials increases, the experimental probability (from simulations) will converge to the theoretical probability.</p> <p>For example, if we simulate the die rolls with a very large number of trials, we expect the estimated probability to approach \\(\\frac{1}{6}\\). Let's modify the simulation to observe this behavior:</p> <pre><code>import matplotlib.pyplot as plt\n\ndef simulate_convergence(n_trials):\n    results = []\n    cumulative_4s = 0\n    for i in range(1, n_trials + 1):\n        if random.randint(1, 6) == 4:\n            cumulative_4s += 1\n        results.append(cumulative_4s / i)\n    return results\n\n# Simulate 100,000 trials\nn_trials = 100000\nconvergence_results = simulate_convergence(n_trials)\n\n# Plot the convergence\nplt.plot(range(1, n_trials + 1), convergence_results)\nplt.axhline(1/6, color='red', linestyle='--', label='Theoretical Probability')\nplt.xlabel('Number of Trials')\nplt.ylabel('Estimated Probability')\nplt.title('Convergence to Theoretical Probability')\nplt.legend()\nplt.show()\n</code></pre> <p>This plot illustrates how the estimated probability stabilizes around the theoretical probability of \\(\\frac{1}{6}\\) as the number of trials increases.</p>"},{"location":"Mechanics/chuas_circuit/","title":"Chua's Circuit","text":""},{"location":"Mechanics/chuas_circuit/#overview","title":"Overview","text":"<p>Chua's Circuit is a simple electronic circuit that exhibits a wide range of nonlinear dynamics, including chaos. It is a physical realization of a chaotic system and has applications in studying nonlinear dynamics and chaos theory.</p> <p>The equations describing Chua's circuit are:</p> \\[ \\frac{dx}{dt} = \\alpha (y - x - h(x)) \\] \\[ \\frac{dy}{dt} = x - y + z \\] \\[ \\frac{dz}{dt} = -\\beta y \\] <p>Where:</p> <ul> <li>\\(h(x)\\) is a piecewise-linear function that models the nonlinear resistance (Chua's diode):   $$ h(x) = m_1 x + 0.5 (m_0 - m_1) (|x + 1| - |x - 1|) $$</li> <li>\\(\\alpha\\), \\(\\beta\\), \\(m_0\\), and \\(m_1\\) are parameters defining the circuit's behavior.</li> </ul>"},{"location":"Mechanics/chuas_circuit/#python-code-example-simulating-and-visualizing-chuas-circuit","title":"Python Code Example: Simulating and Visualizing Chua's Circuit","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import solve_ivp\n\n# Define the piecewise-linear function h(x)\ndef chua_diode(x, m0, m1):\n    return m1 * x + 0.5 * (m0 - m1) * (np.abs(x + 1) - np.abs(x - 1))\n\n# Define the system of equations for Chua's Circuit\ndef chua_circuit(t, state, alpha, beta, m0, m1):\n    x, y, z = state\n    dx_dt = alpha * (y - x - chua_diode(x, m0, m1))\n    dy_dt = x - y + z\n    dz_dt = -beta * y\n    return [dx_dt, dy_dt, dz_dt]\n\n# Parameters\nalpha = 9.0\nbeta = 14.286\nm0 = -1.143\nm1 = -0.714\n\n# Initial conditions\ninitial_state = [0.7, 0.0, 0.0]  # Initial values for x, y, z\n\n# Time span for the simulation\ntime_span = (0, 50)\ntime_eval = np.linspace(time_span[0], time_span[1], 10000)\n\n# Solve the equations\nsolution = solve_ivp(chua_circuit, time_span, initial_state, args=(alpha, beta, m0, m1), t_eval=time_eval, method='RK45')\n\n# Extract the results\nx, y, z = solution.y\n\n# Plot the attractor in 3D\nfig = plt.figure(figsize=(12, 8))\nax = fig.add_subplot(111, projection='3d')\nax.plot(x, y, z, lw=0.5)\nax.set_title(\"Chua's Circuit Attractor\")\nax.set_xlabel(\"x\")\nax.set_ylabel(\"y\")\nax.set_zlabel(\"z\")\nplt.savefig(\"docs/Mechanics/pic/chua_attractor.png\")\nplt.show()\n</code></pre>"},{"location":"Mechanics/chuas_circuit/#key-insights","title":"Key Insights","text":"<ol> <li> <p>Chaos in Electronics: Chua's circuit is a tangible demonstration of chaos, allowing theoretical predictions to be experimentally verified.</p> </li> <li> <p>Piecewise Nonlinearity: The nonlinear resistor introduces the nonlinearity needed for chaotic behavior.</p> </li> <li> <p>Rich Dynamics: Depending on the parameters, the circuit exhibits periodic, quasiperiodic, or chaotic behavior.</p> </li> </ol>"},{"location":"Mechanics/chuas_circuit/#suggested-projects","title":"Suggested Projects","text":"<ol> <li> <p>Parameter Exploration: Investigate how varying \\(\\alpha\\), \\(\\beta\\), \\(m_0\\), and \\(m_1\\) affects the dynamics.</p> </li> <li> <p>Lyapunov Exponent: Compute the Lyapunov exponent to quantify chaos in the circuit.</p> </li> <li> <p>Physical Implementation: Build Chua's circuit with real electronic components and compare the experimental results with simulations.</p> </li> <li> <p>Fractal Dimension: Calculate the fractal dimension of the attractor to understand its complexity.</p> </li> </ol> <p>Chua's Circuit provides a fascinating look into chaos and nonlinear dynamics. Experiment with the parameters and initial conditions to explore its rich behavior!</p>"},{"location":"Mechanics/double_pendulum_trajectories/","title":"Double Pendulum and Sensitivity to Initial Conditions","text":""},{"location":"Mechanics/double_pendulum_trajectories/#overview","title":"Overview","text":"<p>The double pendulum is a classic example of a chaotic system. Its motion is highly sensitive to initial conditions, making it an excellent demonstration of chaos in dynamic systems.</p> <p>The equations of motion for the double pendulum are derived from the Lagrangian and are solved numerically for this analysis.</p>"},{"location":"Mechanics/double_pendulum_trajectories/#python-code-example-simulating-and-plotting-trajectories","title":"Python Code Example: Simulating and Plotting Trajectories","text":"<p>Here is a Python code snippet to simulate and visualize the trajectories of a double pendulum for two slightly different initial conditions:</p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import solve_ivp\n\n# Constants for the double pendulum\nL1, L2 = 1.0, 1.0  # lengths of the pendulum arms\nM1, M2 = 1.0, 1.0  # masses of the pendulums\ng = 9.81  # acceleration due to gravity\n\ndef double_pendulum_ode(t, y):\n    \"\"\"Defines the equations of motion for the double pendulum.\"\"\"\n    theta1, z1, theta2, z2 = y  # Unpack the state vector\n\n    delta = theta2 - theta1\n    den1 = (M1 + M2) * L1 - M2 * L1 * np.cos(delta) ** 2\n    den2 = (L2 / L1) * den1\n\n    dydt = np.zeros_like(y)\n    dydt[0] = z1\n    dydt[1] = (\n        M2 * L1 * z1 ** 2 * np.sin(delta) * np.cos(delta)\n        + M2 * g * np.sin(theta2) * np.cos(delta)\n        + M2 * L2 * z2 ** 2 * np.sin(delta)\n        - (M1 + M2) * g * np.sin(theta1)\n    ) / den1\n    dydt[2] = z2\n    dydt[3] = (\n        -M2 * L2 * z2 ** 2 * np.sin(delta) * np.cos(delta)\n        + (M1 + M2) * g * np.sin(theta1) * np.cos(delta)\n        - (M1 + M2) * L1 * z1 ** 2 * np.sin(delta)\n        - (M1 + M2) * g * np.sin(theta2)\n    ) / den2\n    return dydt\n\n# Initial conditions: two similar starting states\ny0_1 = [np.pi / 4, 0, np.pi / 2, 0]  # [theta1, theta1_dot, theta2, theta2_dot]\ny0_2 = [np.pi / 4 + 0.01, 0, np.pi / 2, 0]  # Slightly perturbed\n\n# Time span for the simulation\nt_span = (0, 20)\nt_eval = np.linspace(t_span[0], t_span[1], 2000)\n\n# Solve the equations of motion\nsol1 = solve_ivp(double_pendulum_ode, t_span, y0_1, t_eval=t_eval, method='RK45')\nsol2 = solve_ivp(double_pendulum_ode, t_span, y0_2, t_eval=t_eval, method='RK45')\n\n# Plot the trajectories of theta1 and theta2\nplt.figure(figsize=(12, 6))\nplt.plot(t_eval, sol1.y[0], label=\"Theta1 (Initial 1)\")\nplt.plot(t_eval, sol1.y[2], label=\"Theta2 (Initial 1)\")\nplt.plot(t_eval, sol2.y[0], label=\"Theta1 (Initial 2)\", linestyle=\"--\")\nplt.plot(t_eval, sol2.y[2], label=\"Theta2 (Initial 2)\", linestyle=\"--\")\nplt.title(\"Trajectories of the Double Pendulum\")\nplt.xlabel(\"Time (s)\")\nplt.ylabel(\"Angle (rad)\")\nplt.legend()\nplt.grid()\nplt.show()\n\n# Plot the difference in trajectories\nplt.figure(figsize=(12, 6))\nplt.plot(t_eval, np.abs(sol1.y[0] - sol2.y[0]), label=\"|Theta1 Difference|\")\nplt.plot(t_eval, np.abs(sol1.y[2] - sol2.y[2]), label=\"|Theta2 Difference|\")\nplt.title(\"Difference Between Trajectories\")\nplt.xlabel(\"Time (s)\")\nplt.ylabel(\"Angle Difference (rad)\")\nplt.legend()\nplt.grid()\nplt.show()\n</code></pre> <p> </p>"},{"location":"Mechanics/double_pendulum_trajectories/#key-insights","title":"Key Insights","text":"<ol> <li> <p>Trajectories Diverge Rapidly: Even with a small initial difference, the trajectories of the double pendulum diverge quickly, illustrating chaotic behavior.</p> </li> <li> <p>Visualization of Sensitivity: The second plot clearly shows how the differences grow over time, emphasizing the system's sensitivity to initial conditions.</p> </li> </ol>"},{"location":"Mechanics/double_pendulum_trajectories/#suggested-projects","title":"Suggested Projects","text":"<ol> <li>Energy Analysis: Calculate and plot the total energy of the system to verify conservation laws.</li> <li>3D Visualization: Extend the analysis to visualize the pendulum's motion in 3D space.</li> <li>Real-World Experiment: Compare the simulation to a physical double pendulum setup.</li> <li>Parameter Variation: Investigate how varying lengths and masses affect the system's dynamics.</li> </ol> <p>This example demonstrates the chaotic nature of the double pendulum and its sensitivity to initial conditions. Try modifying the initial states or parameters to observe how the system behaves!</p>"},{"location":"Mechanics/duffing_oscillator/","title":"Duffing Oscillator","text":""},{"location":"Mechanics/duffing_oscillator/#overview","title":"Overview","text":"<p>The Duffing oscillator is a nonlinear second-order differential equation used to model systems with a restoring force that is not purely linear. It has applications in physics, engineering, and even biology.</p> <p>The equation is:</p> \\[ \\ddot{x} + \\delta \\dot{x} + \\alpha x + \\beta x^3 = \\gamma \\cos(\\omega t) \\] <p>Where: - \\(x\\) is the displacement. - \\(\\delta\\) is the damping coefficient. - \\(\\alpha\\) is the linear stiffness. - \\(\\beta\\) is the nonlinear stiffness. - \\(\\gamma\\) is the amplitude of the driving force. - \\(\\omega\\) is the angular frequency of the driving force.</p>"},{"location":"Mechanics/duffing_oscillator/#python-code-example-simulating-and-visualizing-the-duffing-oscillator","title":"Python Code Example: Simulating and Visualizing the Duffing Oscillator","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import solve_ivp\n\n# Define the Duffing oscillator\ndef duffing(t, state, delta, alpha, beta, gamma, omega):\n    x, dx_dt = state\n    ddx_dt = -delta * dx_dt - alpha * x - beta * x**3 + gamma * np.cos(omega * t)\n    return [dx_dt, ddx_dt]\n\n# Parameters\ndelta = 0.2  # Damping coefficient\nalpha = -1.0  # Linear stiffness\nbeta = 1.0  # Nonlinear stiffness\ngamma = 0.3  # Driving force amplitude\nomega = 1.2  # Driving force frequency\n\n# Initial conditions\ninitial_state = [0.1, 0.0]  # Initial displacement and velocity\n\n# Time span for the simulation\ntime_span = (0, 100)\ntime_eval = np.linspace(time_span[0], time_span[1], 10000)\n\n# Solve the Duffing oscillator\nsolution = solve_ivp(duffing, time_span, initial_state, args=(delta, alpha, beta, gamma, omega), t_eval=time_eval, method='RK45')\n\n# Extract the results\nx, dx_dt = solution.y\n\n# Plot the displacement over time\nplt.figure(figsize=(12, 6))\nplt.plot(solution.t, x, label=\"Displacement\", color=\"blue\")\nplt.title(\"Duffing Oscillator: Displacement Over Time\")\nplt.xlabel(\"Time\")\nplt.ylabel(\"Displacement\")\nplt.grid()\nplt.legend()\nplt.savefig(\"docs/Mechanics/pic/duffing_time.png\")\nplt.show()\n\n# Plot the phase plane\nplt.figure(figsize=(8, 8))\nplt.plot(x, dx_dt, color=\"purple\")\nplt.title(\"Phase Plane of the Duffing Oscillator\")\nplt.xlabel(\"Displacement\")\nplt.ylabel(\"Velocity\")\nplt.grid()\nplt.savefig(\"docs/Mechanics/pic/duffing_phase.png\")\nplt.show()\n</code></pre>"},{"location":"Mechanics/duffing_oscillator/#key-insights","title":"Key Insights","text":"<ol> <li> <p>Nonlinear Dynamics: The cubic term introduces nonlinearity, leading to rich dynamics, including bifurcations and chaos.</p> </li> <li> <p>Phase Space Behavior: The phase plane can reveal limit cycles, chaotic attractors, or other patterns depending on parameters.</p> </li> <li> <p>Driven and Damped System: The interplay of damping, driving force, and nonlinearity determines the behavior of the oscillator.</p> </li> </ol>"},{"location":"Mechanics/duffing_oscillator/#suggested-projects","title":"Suggested Projects","text":"<ol> <li> <p>Bifurcation Analysis: Vary parameters like \\(\\gamma\\) or \\(\\omega\\) to explore transitions between different dynamical regimes.</p> </li> <li> <p>Lyapunov Exponent: Compute the Lyapunov exponent to identify chaotic regions.</p> </li> <li> <p>Comparison with Real Systems: Model physical systems like beam vibrations or electronic circuits.</p> </li> <li> <p>Energy Analysis: Study how energy evolves in the system over time, especially in chaotic regimes.</p> </li> </ol> <p>This example demonstrates the nonlinear dynamics of the Duffing oscillator. Experiment with parameters and initial conditions to uncover its fascinating behavior!</p>"},{"location":"Mechanics/henon_map/","title":"H\u00e9non Map","text":""},{"location":"Mechanics/henon_map/#overview","title":"Overview","text":"<p>The H\u00e9non map is a discrete-time dynamical system that serves as a simple model of chaotic systems. It is defined by a two-dimensional recursive relation:</p> \\[ \\begin{align*} x_{n+1} &amp;= 1 - a x_n^2 + y_n \\\\ y_{n+1} &amp;= b x_n \\end{align*} \\] <p>Where: - \\(a\\) and \\(b\\) are parameters that control the behavior of the system. - \\((x_n, y_n)\\) represents the state of the system at iteration \\(n\\).</p> <p>For the classic values \\(a = 1.4\\) and \\(b = 0.3\\), the map exhibits chaotic behavior and forms a strange attractor.</p>"},{"location":"Mechanics/henon_map/#python-code-example-simulating-and-visualizing-the-henon-map","title":"Python Code Example: Simulating and Visualizing the H\u00e9non Map","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the H\u00e9non map\ndef henon_map(x, y, a, b):\n    x_next = 1 - a * x**2 + y\n    y_next = b * x\n    return x_next, y_next\n\n# Parameters\na = 1.4\nb = 0.3\n\n# Initial conditions\nx, y = 0.0, 0.0\n\n# Number of iterations\niterations = 10000\n\n# Store the results\nx_values = []\ny_values = []\n\n# Iterate the map\nfor _ in range(iterations):\n    x, y = henon_map(x, y, a, b)\n    x_values.append(x)\n    y_values.append(y)\n\n# Plot the H\u00e9non attractor\nplt.figure(figsize=(8, 8))\nplt.scatter(x_values, y_values, s=0.1, color=\"purple\")\nplt.title(\"H\u00e9non Map Attractor\")\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.grid()\nplt.savefig(\"docs/Mechanics/pic/henon_map.png\")\nplt.show()\n</code></pre>"},{"location":"Mechanics/henon_map/#key-insights","title":"Key Insights","text":"<ol> <li> <p>Chaotic Behavior: The H\u00e9non map is one of the simplest systems to exhibit chaos, making it a foundational model in dynamical systems.</p> </li> <li> <p>Strange Attractor: The attractor forms a fractal structure, highlighting the self-similar nature of chaotic systems.</p> </li> <li> <p>Parameter Sensitivity: Small changes in \\(a\\) or \\(b\\) can lead to significant differences in the attractor's shape and dynamics.</p> </li> </ol>"},{"location":"Mechanics/henon_map/#suggested-projects","title":"Suggested Projects","text":"<ol> <li> <p>Parameter Exploration: Investigate how varying \\(a\\) and \\(b\\) affects the attractor's shape and stability.</p> </li> <li> <p>Fractal Dimension: Calculate the fractal dimension of the H\u00e9non attractor to quantify its complexity.</p> </li> <li> <p>Lyapunov Exponent: Compute the Lyapunov exponent to characterize the map's chaotic nature.</p> </li> <li> <p>3D Visualization: Extend the analysis to include a time dimension or color code the points by iteration.</p> </li> </ol> <p>This example introduces the chaotic dynamics of the H\u00e9non map. Experiment with different initial conditions and parameters to uncover the fascinating behavior of this simple yet rich system!</p>"},{"location":"Mechanics/logistic_equation_bifurcation/","title":"Logistic Equation and Bifurcation","text":""},{"location":"Mechanics/logistic_equation_bifurcation/#overview","title":"Overview","text":"<p>The logistic equation is a simple mathematical model that describes population growth with a carrying capacity. The equation is:</p> \\[ x_{n+1} = r x_n (1 - x_n) \\] <p>Where:</p> <ul> <li>\\(x_n\\) is the population at generation \\(n\\) (normalized between 0 and 1).</li> <li>\\(r\\) is the growth rate parameter.</li> </ul> <p>This model exhibits interesting dynamics as the parameter \\(r\\) varies, leading to bifurcations and chaotic behavior.</p>"},{"location":"Mechanics/logistic_equation_bifurcation/#python-code-example-simulating-and-plotting-bifurcations","title":"Python Code Example: Simulating and Plotting Bifurcations","text":"<p>Here is a Python code snippet to simulate and visualize the bifurcation diagram of the logistic equation:</p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the logistic map function, which calculates the next population value\n# given the current population (x) and the growth rate (r).\ndef logistic_map(r, x):\n    return r * x * (1 - x)  # Core equation of the logistic map\n\n# Function to generate and plot the bifurcation diagram\ndef bifurcation_diagram(r_min=2.5, r_max=4.0, steps=10000, discard=1000, plot_points=200):\n    # Generate a range of r values between r_min and r_max.\n    r_values = np.linspace(r_min, r_max, steps)\n\n    # Initialize the population values with an array of 0.5 (arbitrary starting value).\n    x = 0.5 * np.ones(steps)\n\n    # Set up the figure for plotting.\n    plt.figure(figsize=(10, 7))\n\n    # Iterate to discard transient dynamics, ensuring we only analyze steady-state behavior.\n    for _ in range(discard):\n        x = logistic_map(r_values, x)\n\n    # After discarding transients, iterate again to collect data points for the diagram.\n    for _ in range(plot_points):\n        x = logistic_map(r_values, x)\n        # Plot the r values against the current population values (x).\n        plt.plot(r_values, x, ',k', alpha=0.25)  # ',' creates small dots for a dense diagram\n\n    # Add plot titles and labels for clarity.\n    plt.title(\"Bifurcation Diagram of the Logistic Map\")\n    plt.xlabel(\"Growth Rate (r)\")\n    plt.ylabel(\"Population (x)\")\n    plt.grid(True, alpha=0.5)  # Optional grid for better readability\n    plt.show()\n\n# Entry point to execute the bifurcation diagram plot.\nif __name__ == \"__main__\":\n    bifurcation_diagram()  # Call the function with default parameters\n</code></pre> <p></p>"},{"location":"Mechanics/logistic_equation_bifurcation/#key-insights","title":"Key Insights","text":"<ol> <li>Stable Fixed Points: For small \\(r\\), the population converges to a single fixed point.</li> <li>Periodic Orbits: As \\(r\\) increases, bifurcations occur, leading to periodic cycles.</li> <li>Chaos: For \\(r \\geq 3.57\\), chaotic behavior is observed, where the population no longer settles into predictable cycles.</li> </ol>"},{"location":"Mechanics/logistic_equation_bifurcation/#applications","title":"Applications","text":"<ul> <li>Ecology: Modeling species populations.</li> <li>Economics: Describing market dynamics.</li> <li>Physics: Exploring chaotic systems.</li> </ul>"},{"location":"Mechanics/logistic_equation_bifurcation/#advanced-exploration","title":"Advanced Exploration","text":""},{"location":"Mechanics/logistic_equation_bifurcation/#suggested-student-projects","title":"Suggested Student Projects","text":"<p>Students can extend this analysis in the following ways:</p> <ol> <li> <p>Exploration of Lyapunov Exponent: Implement a calculation of the Lyapunov exponent to quantify chaos in the logistic map. This involves computing the average divergence of nearby trajectories.</p> </li> <li> <p>Effect of Initial Conditions: Investigate how varying the initial population \\(x_0\\) affects the bifurcation diagram. Plot diagrams for different \\(x_0\\) values and compare.</p> </li> <li> <p>Parameter Sensitivity: Analyze the sensitivity of the system to small changes in the growth rate \\(r\\) within the chaotic region. Visualize how small perturbations in \\(r\\) can lead to different outcomes.</p> </li> <li> <p>3D Visualization: Extend the bifurcation diagram to include a time dimension, creating a 3D plot to visualize the dynamics.</p> </li> <li> <p>Applications in Real-World Data: Apply the logistic map to real-world data, such as population studies or stock market fluctuations, to see how well it models observed behaviors.</p> </li> <li> <p>Programming Challenge: Implement the bifurcation diagram using a different programming language or visualization library (e.g., JavaScript with D3.js or MATLAB).</p> </li> </ol> <p>This is an introductory example to explore the fascinating behavior of dynamic systems through the logistic equation. Try tweaking the parameters in the code to see how the system's behavior changes!</p>"},{"location":"Mechanics/lorenz_system_and_attractor/","title":"Lorenz System and Attractor","text":""},{"location":"Mechanics/lorenz_system_and_attractor/#overview","title":"Overview","text":"<p>The Lorenz system is a set of three coupled, first-order differential equations that exhibit chaotic behavior for certain parameter values. It was originally derived by Edward Lorenz as a simplified model for atmospheric convection.</p> <p>The equations are:</p> \\[ \\frac{dx}{dt} = \\sigma(y - x) \\] \\[ \\frac{dy}{dt} = x(\\rho - z) - y \\] \\[ \\frac{dz}{dt} = xy - \\beta z \\] <p>Where:</p> <ul> <li>\\(\\sigma\\) is the Prandtl number.</li> <li>\\(\\rho\\) is the Rayleigh number.</li> <li>\\(\\beta\\) is a geometric factor.</li> </ul> <p>For \\(\\sigma = 10\\), \\(\\rho = 28\\), and \\(\\beta = 8/3\\), the system exhibits chaotic behavior.</p>"},{"location":"Mechanics/lorenz_system_and_attractor/#python-code-example-simulating-and-visualizing-the-lorenz-attractor","title":"Python Code Example: Simulating and Visualizing the Lorenz Attractor","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import solve_ivp\n\n# Define the Lorenz system\ndef lorenz(t, state, sigma, rho, beta):\n    x, y, z = state\n    dx_dt = sigma * (y - x)\n    dy_dt = x * (rho - z) - y\n    dz_dt = x * y - beta * z\n    return [dx_dt, dy_dt, dz_dt]\n\n# Parameters\nsigma = 10.0\nrho = 28.0\nbeta = 8 / 3\n\n# Initial conditions\ninitial_state = [1.0, 1.0, 1.0]\n\n# Time span for the simulation\ntime_span = (0, 50)\ntime_eval = np.linspace(time_span[0], time_span[1], 10000)\n\n# Solve the Lorenz system\nsolution = solve_ivp(lorenz, time_span, initial_state, args=(sigma, rho, beta), t_eval=time_eval, method='RK45')\n\n# Extract the results\nx, y, z = solution.y\n\n# Plot the Lorenz attractor\nfig = plt.figure(figsize=(12, 8))\nax = fig.add_subplot(111, projection='3d')\nax.plot(x, y, z, lw=0.5)\nax.set_title(\"Lorenz Attractor\")\nax.set_xlabel(\"X\")\nax.set_ylabel(\"Y\")\nax.set_zlabel(\"Z\")\nplt.savefig(\"docs/Mechanics/pic/lorenz_attractor.png\")\nplt.show()\n</code></pre>"},{"location":"Mechanics/lorenz_system_and_attractor/#key-insights","title":"Key Insights","text":"<ol> <li> <p>Sensitivity to Initial Conditions:    Small differences in initial conditions lead to vastly different trajectories over time, a hallmark of chaos.</p> </li> <li> <p>Attractor Shape:    The trajectories form a butterfly-shaped attractor in 3D space.</p> </li> </ol>"},{"location":"Mechanics/lorenz_system_and_attractor/#suggested-projects","title":"Suggested Projects","text":"<ol> <li> <p>Parameter Exploration: Study how changing \\(\\sigma\\), \\(\\rho\\), and \\(\\beta\\) affects the system\u2019s behavior.</p> </li> <li> <p>Lyapunov Exponent: Quantify the chaos by calculating the Lyapunov exponent of the system.</p> </li> <li> <p>Comparison with Real Systems: Compare the Lorenz system to experimental data from fluid dynamics or weather patterns.</p> </li> <li> <p>3D Visualization: Use interactive tools like Plotly to explore the attractor dynamically.</p> </li> </ol> <p>This example demonstrates the chaotic nature of the Lorenz system. Experiment with the parameters or initial conditions to further explore its dynamics!</p>"},{"location":"Mechanics/pendulum_with_damping_and_forcing/","title":"Pendulum with Damping and Forcing","text":""},{"location":"Mechanics/pendulum_with_damping_and_forcing/#overview","title":"Overview","text":"<p>The forced damped pendulum is a classic example of a nonlinear dynamic system that exhibits a wide range of behaviors, including periodic motion, quasiperiodicity, and chaos. It is governed by the following equation:</p> \\[ \\ddot{\\theta} + b \\dot{\\theta} + c \\sin(\\theta) = A \\cos(\\omega t) \\] <p>Where: - \\(\\theta\\) is the angular displacement. - \\(b\\) is the damping coefficient. - \\(c\\) is the gravitational restoring torque coefficient. - \\(A\\) is the amplitude of the periodic driving force. - \\(\\omega\\) is the angular frequency of the driving force.</p>"},{"location":"Mechanics/pendulum_with_damping_and_forcing/#python-code-example-simulating-and-visualizing-the-forced-damped-pendulum","title":"Python Code Example: Simulating and Visualizing the Forced Damped Pendulum","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import solve_ivp\n\n# Define the forced damped pendulum equations\ndef forced_damped_pendulum(t, state, b, c, A, omega):\n    theta, omega_theta = state\n    dtheta_dt = omega_theta\n    domega_dt = -b * omega_theta - c * np.sin(theta) + A * np.cos(omega * t)\n    return [dtheta_dt, domega_dt]\n\n# Parameters\nb = 0.5  # Damping coefficient\nc = 9.8  # Restoring torque coefficient\nA = 1.2  # Amplitude of the driving force\nomega = 2.0  # Angular frequency of the driving force\n\n# Initial conditions\ninitial_state = [0.1, 0.0]  # Initial angle and angular velocity\n\n# Time span for the simulation\ntime_span = (0, 50)\ntime_eval = np.linspace(time_span[0], time_span[1], 10000)\n\n# Solve the equations\nsolution = solve_ivp(forced_damped_pendulum, time_span, initial_state, args=(b, c, A, omega), t_eval=time_eval, method='RK45')\n\n# Extract the results\ntheta, omega_theta = solution.y\n\n# Unwrap the angle for better visualization\ntheta = np.unwrap(theta)\n\n# Plot the angular displacement over time\nplt.figure(figsize=(12, 6))\nplt.plot(solution.t, theta, label=\"Angular Displacement\", color=\"blue\")\nplt.title(\"Forced Damped Pendulum: Angular Displacement Over Time\")\nplt.xlabel(\"Time\")\nplt.ylabel(\"Angular Displacement (radians)\")\nplt.grid()\nplt.legend()\nplt.savefig(\"docs/Mechanics/pic/forced_damped_pendulum_time.png\")\nplt.show()\n\n# Plot the phase plane\nplt.figure(figsize=(8, 8))\nplt.plot(theta, omega_theta, color=\"purple\")\nplt.title(\"Phase Plane of the Forced Damped Pendulum\")\nplt.xlabel(\"Angular Displacement (radians)\")\nplt.ylabel(\"Angular Velocity\")\nplt.grid()\nplt.savefig(\"docs/Mechanics/pic/forced_damped_pendulum_phase.png\")\nplt.show()\n</code></pre>"},{"location":"Mechanics/pendulum_with_damping_and_forcing/#key-insights","title":"Key Insights","text":"<ol> <li> <p>Nonlinear Dynamics: The interaction between damping, restoring force, and driving force creates complex dynamics.</p> </li> <li> <p>Phase Space Behavior: The phase plane reveals different regimes: limit cycles, quasiperiodic orbits, and chaotic attractors.</p> </li> <li> <p>Sensitivity to Parameters: Small changes in \\(b\\), \\(c\\), \\(A\\), or \\(\\omega\\) can lead to drastically different behaviors.</p> </li> </ol>"},{"location":"Mechanics/pendulum_with_damping_and_forcing/#suggested-projects","title":"Suggested Projects","text":"<ol> <li> <p>Parameter Exploration: Investigate the effects of varying \\(A\\) and \\(\\omega\\) to explore transitions between periodic, quasiperiodic, and chaotic motion.</p> </li> <li> <p>Poincar\u00e9 Section: Visualize the system's dynamics using a Poincar\u00e9 section to identify periodic orbits and chaos.</p> </li> <li> <p>Energy Analysis: Study the energy evolution in the system and identify energy dissipation and driving force contributions.</p> </li> <li> <p>Comparison with Real Pendulums: Build a physical forced pendulum and compare its motion to the simulation.</p> </li> </ol> <p>The forced damped pendulum serves as a rich system for studying nonlinear dynamics. Experiment with the parameters and initial conditions to uncover its fascinating behaviors!</p>"},{"location":"Mechanics/predator_prey_model/","title":"Lotka-Volterra Equations (Predator-Prey Model)","text":""},{"location":"Mechanics/predator_prey_model/#overview","title":"Overview","text":"<p>The Lotka-Volterra equations are a pair of first-order, non-linear differential equations frequently used to describe the dynamics of biological systems in which two species interact, one as a predator and the other as prey.</p> <p>The equations are:</p> \\[ \\frac{dx}{dt} = \\alpha x - \\beta xy \\] \\[ \\frac{dy}{dt} = \\delta xy - \\gamma y \\] <p>Where:</p> <ul> <li>\\(x\\) is the population of the prey.</li> <li>\\(y\\) is the population of the predator.</li> <li>\\(\\alpha\\) is the growth rate of the prey.</li> <li>\\(\\beta\\) is the rate at which predators consume prey.</li> <li>\\(\\gamma\\) is the death rate of the predators.</li> <li>\\(\\delta\\) is the rate at which predators increase by consuming prey.</li> </ul>"},{"location":"Mechanics/predator_prey_model/#python-code-example-simulating-and-visualizing-the-lotka-volterra-equations","title":"Python Code Example: Simulating and Visualizing the Lotka-Volterra Equations","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import solve_ivp\n\n# Define the Lotka-Volterra equations\ndef lotka_volterra(t, state, alpha, beta, gamma, delta):\n    x, y = state\n    dx_dt = alpha * x - beta * x * y\n    dy_dt = delta * x * y - gamma * y\n    return [dx_dt, dy_dt]\n\n# Parameters\nalpha = 0.1  # Prey growth rate\nbeta = 0.02  # Predator consumption rate\ngamma = 0.3  # Predator death rate\ndelta = 0.01  # Predator reproduction rate\n\n# Initial conditions\ninitial_state = [40, 9]  # Initial populations of prey and predator\n\n# Time span for the simulation\ntime_span = (0, 200)\ntime_eval = np.linspace(time_span[0], time_span[1], 1000)\n\n# Solve the Lotka-Volterra equations\nsolution = solve_ivp(lotka_volterra, time_span, initial_state, args=(alpha, beta, gamma, delta), t_eval=time_eval, method='RK45')\n\n# Extract the results\nprey, predator = solution.y\n\n# Plot the populations over time\nplt.figure(figsize=(12, 6))\nplt.plot(solution.t, prey, label=\"Prey Population\", color=\"blue\")\nplt.plot(solution.t, predator, label=\"Predator Population\", color=\"red\")\nplt.title(\"Lotka-Volterra Predator-Prey Model\")\nplt.xlabel(\"Time\")\nplt.ylabel(\"Population\")\nplt.legend()\nplt.grid()\nplt.savefig(\"docs/Mechanics/pic/lotka_volterra_time.png\")\nplt.show()\n\n# Plot the phase plane\nplt.figure(figsize=(8, 8))\nplt.plot(prey, predator, color=\"purple\")\nplt.title(\"Phase Plane of the Lotka-Volterra Model\")\nplt.xlabel(\"Prey Population\")\nplt.ylabel(\"Predator Population\")\nplt.grid()\nplt.savefig(\"docs/Mechanics/pic/lotka_volterra_phase.png\")\nplt.show()\n</code></pre>"},{"location":"Mechanics/predator_prey_model/#key-insights","title":"Key Insights","text":"<ol> <li> <p>Oscillatory Behavior: The populations of prey and predators tend to oscillate over time, with predator peaks lagging behind prey peaks.</p> </li> <li> <p>Phase Plane: The phase plane reveals closed orbits, indicating periodic solutions depending on initial conditions.</p> </li> <li> <p>Nonlinearity: The interaction terms (\\(\\beta xy\\) and \\(\\delta xy\\)) introduce nonlinearity, leading to complex dynamics.</p> </li> </ol>"},{"location":"Mechanics/predator_prey_model/#suggested-projects","title":"Suggested Projects","text":"<ol> <li> <p>Parameter Sensitivity: Investigate how varying \\(\\alpha\\), \\(\\beta\\), \\(\\gamma\\), and \\(\\delta\\) affects the dynamics.</p> </li> <li> <p>Stability Analysis: Analyze the stability of the fixed points to understand long-term behavior.</p> </li> <li> <p>Real-World Data: Fit the Lotka-Volterra model to real-world predator-prey data to evaluate its applicability.</p> </li> <li> <p>Extensions: Add additional species or environmental factors to study more complex ecosystems.</p> </li> </ol> <p>This example provides a basic introduction to the predator-prey dynamics described by the Lotka-Volterra equations. Experiment with different parameters and initial conditions to observe the rich behavior of this classic model.</p>"},{"location":"Mechanics/three_body_problem/","title":"Three-Body Problem in a Plane","text":""},{"location":"Mechanics/three_body_problem/#overview","title":"Overview","text":"<p>The three-body problem is a classical problem in celestial mechanics that describes the motion of three masses under their mutual gravitational attraction. In the planar case, all three bodies move within a single plane.</p> <p>The equations of motion for each body are derived from Newton's law of gravitation:</p> \\[ \\ddot{\\vec{r}}_i = G \\sum_{j \\neq i} m_j \\frac{\\vec{r}_j - \\vec{r}_i}{|\\vec{r}_j - \\vec{r}_i|^3}, \\] <p>where: - \\(\\vec{r}_i\\) is the position vector of the \\(i\\)-th body. - \\(m_j\\) is the mass of the \\(j\\)-th body. - \\(G\\) is the gravitational constant.</p>"},{"location":"Mechanics/three_body_problem/#python-code-example-simulating-and-visualizing-the-planar-three-body-problem","title":"Python Code Example: Simulating and Visualizing the Planar Three-Body Problem","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import solve_ivp\n\n# Define the equations of motion for the three-body problem\ndef three_body_equations(t, state, G, m1, m2, m3):\n    r1 = state[:2]\n    r2 = state[2:4]\n    r3 = state[4:6]\n    v1 = state[6:8]\n    v2 = state[8:10]\n    v3 = state[10:12]\n\n    # Distances between bodies\n    r12 = np.linalg.norm(r2 - r1)\n    r13 = np.linalg.norm(r3 - r1)\n    r23 = np.linalg.norm(r3 - r2)\n\n    # Accelerations\n    a1 = G * m2 * (r2 - r1) / r12**3 + G * m3 * (r3 - r1) / r13**3\n    a2 = G * m1 * (r1 - r2) / r12**3 + G * m3 * (r3 - r2) / r23**3\n    a3 = G * m1 * (r1 - r3) / r13**3 + G * m2 * (r2 - r3) / r23**3\n\n    return np.concatenate([v1, v2, v3, a1, a2, a3])\n\n# Parameters\nG = 1.0  # Gravitational constant\nm1, m2, m3 = 1.0, 1.0, 1.0  # Masses of the three bodies\n\n# Initial positions and velocities (in the plane)\ninitial_positions = [\n    [0.5, 0.0],  # Body 1\n    [-0.5, 0.0],  # Body 2\n    [0.0, 0.5],   # Body 3\n]\ninitial_velocities = [\n    [0.0, 0.1],  # Body 1\n    [0.0, -0.1],  # Body 2\n    [-0.1, 0.0],  # Body 3\n]\n\n# Flatten initial conditions\ninitial_state = np.concatenate([\n    np.array(initial_positions).flatten(),\n    np.array(initial_velocities).flatten()\n])\n\n# Time span for the simulation\ntime_span = (0, 10)\ntime_eval = np.linspace(time_span[0], time_span[1], 1000)\n\n# Solve the equations\nsolution = solve_ivp(\n    three_body_equations, time_span, initial_state, args=(G, m1, m2, m3),\n    t_eval=time_eval, method='RK45'\n)\n\n# Extract the results\nr1 = solution.y[:2].T\nr2 = solution.y[2:4].T\nr3 = solution.y[4:6].T\n\n# Plot the trajectories\nplt.figure(figsize=(10, 10))\nplt.plot(r1[:, 0], r1[:, 1], label=\"Body 1\", color=\"blue\")\nplt.plot(r2[:, 0], r2[:, 1], label=\"Body 2\", color=\"red\")\nplt.plot(r3[:, 0], r3[:, 1], label=\"Body 3\", color=\"green\")\nplt.scatter(initial_positions[0][0], initial_positions[0][1], color=\"blue\", marker=\"o\")\nplt.scatter(initial_positions[1][0], initial_positions[1][1], color=\"red\", marker=\"o\")\nplt.scatter(initial_positions[2][0], initial_positions[2][1], color=\"green\", marker=\"o\")\nplt.title(\"Three-Body Problem Trajectories\")\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.legend()\nplt.grid()\nplt.savefig(\"docs/Mechanics/pic/three_body_problem.png\")\nplt.show()\n</code></pre>"},{"location":"Mechanics/three_body_problem/#key-insights","title":"Key Insights","text":"<ol> <li> <p>Nonlinearity and Chaos: The three-body problem is highly nonlinear and exhibits sensitive dependence on initial conditions, leading to chaotic trajectories.</p> </li> <li> <p>Unpredictability: Long-term predictions of the bodies' positions are inherently limited by numerical precision and initial condition accuracy.</p> </li> <li> <p>Conservation Laws: The system conserves total energy and angular momentum, providing useful checks for numerical simulations.</p> </li> </ol>"},{"location":"Mechanics/three_body_problem/#suggested-projects","title":"Suggested Projects","text":"<ol> <li> <p>Energy Conservation: Calculate and verify the conservation of total energy throughout the simulation.</p> </li> <li> <p>Initial Condition Sensitivity: Explore how small changes in initial positions or velocities affect the trajectories.</p> </li> <li> <p>Visualization Enhancements: Create interactive 3D visualizations or add color coding for time progression.</p> </li> <li> <p>Symmetrical Configurations: Investigate special cases such as equilateral triangle orbits and their stability.</p> </li> </ol> <p>The planar three-body problem is a rich source of nonlinear dynamics and chaos. Experiment with different initial conditions and parameters to explore its fascinating behaviors!</p>"}]}